unit Test.SyntaxChecker;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Variants, System.SysUtils, Utils, StrUtils,
  Ladder.ServiceLocator, SynDB, SynCommons, Ladder.Utils, Ladder.SyntaxChecker;

type
  TestTSyntaxChecker = class(TTestCase)
  strict private
    FSyntaxChecker: TSyntaxChecker;
  private
    procedure FunElementEval(const pElement: String; var Return: Variant);
    procedure FunSqlEval(const pSql: String; var Return: Variant);
    procedure CheckSyntax(AExpression: String);
    procedure CheckSyntaxFalse(AExpression: String);
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCheckNumber;
    procedure TestCheckString;
    procedure TestCheckList;
    procedure TestCheckIndex;
    procedure TestCheckElement;
    procedure TestCheckSql;
  end;

implementation

uses
  Math;

{ TestTSyntaxChecker }

procedure TestTSyntaxChecker.CheckSyntax(AExpression: String);
var
  FErrMsg: String;
  FReturn: Boolean;
begin
  FReturn:= FSyntaxChecker.DoCheckSyntax(AExpression, FErrMsg);
  Check(FReturn, FErrMsg);
end;

procedure TestTSyntaxChecker.CheckSyntaxFalse(AExpression: String);
var
  FErrMsg: String;
  FReturn: Boolean;
begin
  FReturn:= FSyntaxChecker.DoCheckSyntax(AExpression, FErrMsg);
  CheckFalse(FReturn, FErrMsg);
end;

procedure TestTSyntaxChecker.FunElementEval(const pElement: String;
  var Return: Variant);
begin
  Return:= Null;
  if (pElement = 't1') or (pElement = 't2') or (pElement = 't1.prop') then
  else
    raise Exception.Create(Format('Element %s not found', [pElement]));
end;

procedure TestTSyntaxChecker.FunSqlEval(const pSql: String;
  var Return: Variant);
begin

end;

procedure TestTSyntaxChecker.SetUp;
begin
  inherited;
  FSyntaxChecker:= TSyntaxChecker.Create(FunElementEval, FunSqlEval);
end;

procedure TestTSyntaxChecker.TearDown;
begin
  FSyntaxChecker.Free;
  inherited;
end;

procedure TestTSyntaxChecker.TestCheckElement;
const
  sElement = '@t1';
  sElement2 = '@t1.prop';
  sElement3 = '@t1.prop[0]';
  sElement5 = '@t2';
  sElementArray = '[@t1, @t2, @t1.prop]';
  sInv1 = '@Ela';
  sInv2 = '@t1.prop,"ignorar"';
begin
  CheckSyntax(sElement);
  CheckSyntax(sElement2);
  CheckSyntax(sElement3);
  CheckSyntax(sElement5);
  CheckSyntax(sElementArray);
  CheckSyntaxFalse(sInv1);
  CheckSyntaxFalse(sInv2);
end;

procedure TestTSyntaxChecker.TestCheckIndex;
const
  sTest1 = '["a", "b", "c"][0]';
  sTest2 = '["a", "b", "c"][1]';
  sTest3 = '["a", "b", "c"][2]';
  sTest4 = '["a", ["b", "c"], "d"][1][1]';
  sTest5 = '$SELECT ''T'' UNION SELECT ''E''$[1][0]';
  sTest6 = '$SELECT 1 as idx, ''T'' as nome UNION SELECT 2, ''E''$[1]["idx"]';
  sTest7 = '$SELECT 1 as idx, ''T'' as nome UNION SELECT 2, ''E''$[1]["NOME"]';
  sTestInv = '["a", ["b", "c"][]';
begin
  CheckSyntax(sTest1);
  CheckSyntax(sTest2);
  CheckSyntax(sTest3);
  CheckSyntax(sTest4);
  CheckSyntax(sTest5);
  CheckSyntax(sTest6);
  CheckSyntax(sTest7);
  CheckSyntaxFalse(sTestInv);
end;

procedure TestTSyntaxChecker.TestCheckList;
const
  sEmptyList = '[]';
  sNumberList = '[123,11,"teste"]';
  sStringList = '["bla"]';
  sMultiList = '["co", "ro", "na"]';
  sListOfList = '[[1,2,3], "ro", "na"][1]';
  sItemInterpolated = '["{"co"}rona", "ro", "na"]';
  sInvalid = ',]';
  sNoClose = '["alo", "ha" ';
begin
  CheckSyntax(sEmptyList);
  CheckSyntax(sNumberList);
  CheckSyntax(sStringList);
  CheckSyntax(sMultiList);
  CheckSyntax(sListOfList);
  CheckSyntax(sItemInterpolated);
  CheckSyntaxFalse(sInvalid);
  CheckSyntaxFalse(sNoClose);
end;

procedure TestTSyntaxChecker.TestCheckNumber;
const
  cInt1 = '10 ';
  cInt2 = ' 12344';
  cIntInvalid = '12a';
  cFloat1 = '875.5554';
  cFloat2 = '999997775.52222';
  cFloatInvalid = '9999922.222a';
  cFloatInvalid2 = '8.75.75';
begin
  CheckSyntax(cInt1);
  CheckSyntax(cInt2);
  CheckSyntaxFalse(cIntInvalid);
  CheckSyntax(cFloat1);
  CheckSyntax(cFloat2);
  CheckSyntaxFalse(cFloatInvalid);
  CheckSyntaxFalse(cFloatInvalid2);
end;

procedure TestTSyntaxChecker.TestCheckSql;
const
  cSql1 = '$select $';
  cSql2 = '$select {"Nome"}';
  cInvalidSql = '$select {1abc}';
  cInv2 = '$ $';
begin
  CheckSyntax(cSql1);
  CheckSyntax(cSql2);
  CheckSyntaxFalse(cInvalidSql);
  CheckSyntaxFalse(cInv2);
end;

procedure TestTSyntaxChecker.TestCheckString;
const
  sEmpty = '""';
  s1 = '" blabla bla () {"123"} "';
  s1Interpolated = ' blabla bla () 123 ';
//  s1Result = '" blabla bla () 123 "123" "';
  sHeineken = 'Heineken';
  sOpenEnded = '"corona ';
  s123 = '"123"';
begin
  CheckSyntax(sEmpty);
  CheckSyntax(s1);
  CheckSyntax(s123);
  CheckSyntax(sHeineken);
  CheckSyntax(s1Interpolated);
  CheckSyntaxFalse(sOpenEnded);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTSyntaxChecker.Suite);

end.
